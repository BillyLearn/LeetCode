#### [1162 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

### 题目题意

你现在手里有一份大小为 $N \times N$ 的 网格  grid，上面的每个 单元格 都用 0 和 1 标记好了。

其中 0  代表海洋，1  代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。

我们这里说的距离是「曼哈顿距离」$ Manhattan Distance）：(x0, y0)$ 和  $(x1, y1)$ 这两个单元格之间的距离是 $|x0 - x1| + |y0 - y1|$ 。

如果网格上只有陆地或者海洋，请返回 -1。



**示例 1：**

|  1   |  0   |  1   |
| :--: | :--: | :--: |
|  0   |  0   |  0   |
|  1   |  0   |  1   |

```bash
输入：[[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。
```

**示例 2：**

|  1   |  0   |  0   |
| :--: | :--: | :--: |
|  0   |  0   |  0   |
|  0   |  0   |  0   |

```
输入：[[1,0,0],[0,0,0],[0,0,0]]
输出：4
解释： 
海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。
```


提示：

- $1 <= grid.length == grid[0].length <= 100$
- $ grid[i][j] $不是 0,  就是 1 ​

### **个人分析 : **

单元格下标，可以看成二维向量坐标。求最大距离，

先知道距离计算公式:

$(x_0,y_0), (x_1,y_1)$ 这里两个坐标可以表示 (0,0) , (1,1)

坐标是坐标值，跟海洋 0 和陆地 1 不是同样的意义，两者不要混淆。

示例2的描述，海洋单元格（2,2）就是表示坐标值。下标从0开始，对应就是最下角的位置 0 

陆地就只有最上角的位置 1， 即坐标位置就是 (0, 0)

代入公式可得
$$
res = |x0 - x1| + |y0 - y1| = |0 - 2| + | 0 - 2| = 4
$$
最大距离为 4

#### 动态规划方法

「把陆地区域作为源点集、海洋区域作为目标点集，求最短路」的过程。我们知道对于每个海洋区域 (x, y)，离它最近的陆地区域到它的路径要么从上方或者左方来，要么从右方或者下方来。考虑做两次动态规划，第一次从左上到右下，第二次从右下到左上，记 f(x, y)为 (x, y) 距离最近的陆地区域的曼哈顿距离，则我们可以推出这样的转移方程：

第一阶段	
$$
f(x, y)=\left\{\begin{array}{ll}
0 & ,(x, y) \text { is land } \\
\min \{f(x-1, y), f(x, y-1)\}+1 & ,(x, y) \text { is ocean }
\end{array}\right.
$$


第二阶段


$$
f(x, y)=\left\{\begin{array}{ll}
0 & ,(x, y) \text { is land } \\
\min \{f(x+1, y), f(x, y+1)\}+1 & ,(x, y) \text { is ocean }
\end{array}\right.
$$
​	


我们初始化的时候把陆地的 f 值全部预置为 0，海洋的 f 全部预置为 INF，做完两个阶段的动态规划后，我们在所有的不为零的 $f[i][j] $中比一个最大值即可，如果最终比较出的最大值为 INF，就返回 -1。

思考：如果用 $f(x, y)$ 记录左上方的 DP 结果，$g(x, y)$ 记录右下方的DP结果可行吗？ 答案是不可行。因为考虑距离点 $(x, y)$最近的点可能既不来自左上方，也不来自右下方，比如它来自右上方，这个时候，第二阶段我们就需要用到第一阶段的计算结果。

```c++
class Solution {
public:
    static constexpr int MAX_N = 100 + 5;
    static constexpr int INF = int(1E6);
    
    int f[MAX_N][MAX_N];
    int n;

    int maxDistance(vector<vector<int>>& grid) {
        this->n = grid.size();
        vector<vector<int>>& a = grid;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                f[i][j] = (a[i][j] ? 0 : INF);
            }
        }

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (a[i][j]) {
                    continue;
                }
                if (i - 1 >= 0) {
                    f[i][j] = min(f[i][j], f[i - 1][j] + 1);
                }
                if (j - 1 >= 0) {
                    f[i][j] = min(f[i][j], f[i][j - 1] + 1);
                }
            }
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                if (a[i][j]) {
                    continue;
                }
                if (i + 1 < n) {
                    f[i][j] = min(f[i][j], f[i + 1][j] + 1);
                }
                if (j + 1 < n) {
                    f[i][j] = min(f[i][j], f[i][j + 1] + 1);
                }
            }
        }

        int ans = -1;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (!a[i][j]) {
                    ans = max(ans, f[i][j]);
                }
            }
        }

        if (ans == INF) {
            return -1;
        } else {
            return ans;
        }
    }
};
```

