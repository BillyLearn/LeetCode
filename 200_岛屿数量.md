#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```bash
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```



**示例 2：**

```bash
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```



**提示：**

- $m == grid.length$ 
- $n == grid[i].length$ 
- $1 <= m, n <= 300 $
- $ grid[i][j] 的值为 '0' 或 '1' $



**个人分析（深度搜索）：**

在某个 1 的竖直方向和水平方向，相邻为 1 的岛屿算是个一个岛屿

|   <font color='greed'>1</font>   |   <font color='greed'>1</font>   |               0                |                0                |                0                |
| :------------------------------: | :------------------------------: | :----------------------------: | :-----------------------------: | :-----------------------------: |
| <font color='greed'>**1**</font> | <font color='greed'>**1**</font> |               0                |                0                |                0                |
|                0                 |                0                 | <font color='red'>**1**</font> |                0                |                0                |
|                0                 |                0                 |               0                | <font color='blue'>**1**</font> | <font color='blue'>**1**</font> |

4个绿色 1，相邻1，所以只算一个岛屿。

红色 1 的，四个方向，左右上下，都没有1，算是一个岛屿。

两个相邻蓝色 1，只要四个方向再没有 1， 也算一个岛屿。

综上，总共有 3 个岛屿。

**C++实现：**

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution{
private:
    void dfs(vector<vector<char> >& grid, int r, int c){
        int row = grid.size();
        int col = grid[0].size();

        grid[r][c] = '0';
        // 四个方向,左，右，上，下
        // 左,行数不变，列减一
        if (c - 1 > 0 && grid[r][c-1] == '1'){
            dfs(grid, r, c - 1);
        }

        // 右
        if (c + 1 < col && grid[r][c+1] == '1'){
            dfs(grid, r, c + 1);
        }

        // 上,列数不变，行减一
        if (r - 1 >= 0 && grid[r - 1][c] == '1'){
            dfs(grid, r - 1, c);
        }
        // 下
        if (r + 1 < row && grid[r + 1][c] == '1'){
            dfs(grid, r + 1, c);
        }
    }

public:
    int num_islands(vector<vector<char> > grid)
    {
        int row = grid.size();
        int col = grid[0].size();
        int num = 0;

        for (int i = 0; i < row; i++)
        {
            for (int j = 0; j < col; j++)
            {
                if (grid[i][j] == '1'){
                    num ++;
                    dfs(grid,i,j);
                }
            }
        }
        return num;
    }
};

int main()
{
    vector<vector<char> > grid = {
            {'1','1','1','1','0'},
            {'1','1','0','1','0'},
            {'1','1','0','0','0'},
            {'0','0','0','0','0'}
        };

    vector<vector<char> > grid1 = {
            {'1','1','0','0','0'},
            {'1','1','0','0','0'},
            {'0','0','1','0','0'},
            {'0','0','0','1','1'}
        };

    Solution s;
    cout << s.num_islands(grid) << endl;
    cout << s.num_islands(grid1) << endl;
    return 0;
}
```

